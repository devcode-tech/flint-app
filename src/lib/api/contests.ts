import { supabase, type Contest } from '@/lib/supabase/client'
import type { CompleteContestData } from '@/schemas/contestSchema'

export async function createContest(data: CompleteContestData, formId: string) {
  const { data: contest, error } = await supabase
    .from('contests')
    .insert({
      name: data.basicDetails.name,
      contest_type: data.basicDetails.contestType,
      start_date: data.basicDetails.startDate,
      end_date: data.basicDetails.endDate,
      form_id: formId,
      actions: data.actions,
      post_capture: data.postCapture,
      targeting: data.targeting,
      status: 'draft'
      // embed_id will be auto-generated by database trigger
    })
    .select()
    .single()

  if (error) {
    console.error('Error creating contest:', error)
    throw new Error(error.message)
  }
  
  return contest as Contest
}

export async function updateContest(
  contestId: string,
  data: CompleteContestData,
  formId: string
) {
  const { data: contest, error } = await supabase
    .from('contests')
    .update({
      name: data.basicDetails.name,
      contest_type: data.basicDetails.contestType,
      start_date: data.basicDetails.startDate,
      end_date: data.basicDetails.endDate,
      form_id: formId,
      actions: data.actions,
      post_capture: data.postCapture,
      targeting: data.targeting,
      updated_at: new Date().toISOString()
    })
    .eq('id', contestId) // Use UUID for updates
    .select()
    .single()

  if (error) {
    console.error('Error updating contest:', error)
    throw new Error(error.message)
  }
  
  return contest as Contest
}

export async function getContest(contestId: string) {
  const { data: contest, error } = await supabase
    .from('contests')
    .select(`
      *,
      form:forms(*)
    `)
    .eq('id', contestId) // Use UUID for fetching
    .single()

  if (error) {
    console.error('Error fetching contest:', error)
    throw new Error(error.message)
  }
  
  return contest as Contest
}

export async function getContestByEmbedId(embedId: string) {
  // For public embedding - use embed_id
  const { data: contest, error } = await supabase
    .from('contests')
    .select(`
      *,
      form:forms(*)
    `)
    .eq('embed_id', embedId)
    .eq('status', 'active') // Only active contests can be embedded
    .single()

  if (error) {
    console.error('Error fetching contest by embed ID:', error)
    throw new Error(error.message)
  }
  
  return contest as Contest
}

export async function listContests(limit = 50, offset = 0) {
  const { data: contests, error, count } = await supabase
    .from('contests')
    .select(`
      id,
      embed_id,
      name,
      contest_type,
      start_date,
      end_date,
      status,
      created_at
    `, { count: 'exact' })
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1)

  if (error) {
    console.error('Error listing contests:', error)
    throw new Error(error.message)
  }
  
  return { contests: contests as Contest[], total: count || 0 }
}

export async function deleteContest(contestId: string) {
  const { error } = await supabase
    .from('contests')
    .delete()
    .eq('id', contestId)

  if (error) {
    console.error('Error deleting contest:', error)
    throw new Error(error.message)
  }
}

export async function updateContestStatus(
  contestId: string,
  status: 'draft' | 'active' | 'completed' | 'archived'
) {
  const { data: contest, error } = await supabase
    .from('contests')
    .update({ status, updated_at: new Date().toISOString() })
    .eq('id', contestId)
    .select()
    .single()

  if (error) {
    console.error('Error updating contest status:', error)
    throw new Error(error.message)
  }
  
  return contest as Contest
}
